// Code generated by protoc-gen-go. DO NOT EDIT.
// source: nc.proto

/*
Package nc is a generated protocol buffer package.

It is generated from these files:
	nc.proto

It has these top-level messages:
	DataRate
	RXInfo
	TXInfo
	HandleRXInfoRequest
	HandleRXInfoResponse
	HandleDataUpMACCommandRequest
	HandleDataUpMACCommandResponse
	HandleErrorRequest
	HandleErrorResponse
*/
package nc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DataRate struct {
	Modulation   string `protobuf:"bytes,1,opt,name=modulation" json:"modulation,omitempty"`
	BandWidth    uint32 `protobuf:"varint,2,opt,name=bandWidth" json:"bandWidth,omitempty"`
	SpreadFactor uint32 `protobuf:"varint,3,opt,name=spreadFactor" json:"spreadFactor,omitempty"`
	Bitrate      uint32 `protobuf:"varint,4,opt,name=bitrate" json:"bitrate,omitempty"`
}

func (m *DataRate) Reset()                    { *m = DataRate{} }
func (m *DataRate) String() string            { return proto.CompactTextString(m) }
func (*DataRate) ProtoMessage()               {}
func (*DataRate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DataRate) GetModulation() string {
	if m != nil {
		return m.Modulation
	}
	return ""
}

func (m *DataRate) GetBandWidth() uint32 {
	if m != nil {
		return m.BandWidth
	}
	return 0
}

func (m *DataRate) GetSpreadFactor() uint32 {
	if m != nil {
		return m.SpreadFactor
	}
	return 0
}

func (m *DataRate) GetBitrate() uint32 {
	if m != nil {
		return m.Bitrate
	}
	return 0
}

type RXInfo struct {
	Mac     []byte  `protobuf:"bytes,1,opt,name=mac,proto3" json:"mac,omitempty"`
	Time    string  `protobuf:"bytes,2,opt,name=time" json:"time,omitempty"`
	Rssi    int32   `protobuf:"varint,3,opt,name=rssi" json:"rssi,omitempty"`
	LoRaSNR float64 `protobuf:"fixed64,4,opt,name=loRaSNR" json:"loRaSNR,omitempty"`
}

func (m *RXInfo) Reset()                    { *m = RXInfo{} }
func (m *RXInfo) String() string            { return proto.CompactTextString(m) }
func (*RXInfo) ProtoMessage()               {}
func (*RXInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *RXInfo) GetMac() []byte {
	if m != nil {
		return m.Mac
	}
	return nil
}

func (m *RXInfo) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *RXInfo) GetRssi() int32 {
	if m != nil {
		return m.Rssi
	}
	return 0
}

func (m *RXInfo) GetLoRaSNR() float64 {
	if m != nil {
		return m.LoRaSNR
	}
	return 0
}

type TXInfo struct {
	Frequency int64     `protobuf:"varint,1,opt,name=frequency" json:"frequency,omitempty"`
	DataRate  *DataRate `protobuf:"bytes,2,opt,name=dataRate" json:"dataRate,omitempty"`
	Adr       bool      `protobuf:"varint,3,opt,name=adr" json:"adr,omitempty"`
	CodeRate  string    `protobuf:"bytes,4,opt,name=codeRate" json:"codeRate,omitempty"`
}

func (m *TXInfo) Reset()                    { *m = TXInfo{} }
func (m *TXInfo) String() string            { return proto.CompactTextString(m) }
func (*TXInfo) ProtoMessage()               {}
func (*TXInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TXInfo) GetFrequency() int64 {
	if m != nil {
		return m.Frequency
	}
	return 0
}

func (m *TXInfo) GetDataRate() *DataRate {
	if m != nil {
		return m.DataRate
	}
	return nil
}

func (m *TXInfo) GetAdr() bool {
	if m != nil {
		return m.Adr
	}
	return false
}

func (m *TXInfo) GetCodeRate() string {
	if m != nil {
		return m.CodeRate
	}
	return ""
}

type HandleRXInfoRequest struct {
	DevEUI []byte    `protobuf:"bytes,1,opt,name=devEUI,proto3" json:"devEUI,omitempty"`
	TxInfo *TXInfo   `protobuf:"bytes,3,opt,name=txInfo" json:"txInfo,omitempty"`
	RxInfo []*RXInfo `protobuf:"bytes,4,rep,name=rxInfo" json:"rxInfo,omitempty"`
}

func (m *HandleRXInfoRequest) Reset()                    { *m = HandleRXInfoRequest{} }
func (m *HandleRXInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*HandleRXInfoRequest) ProtoMessage()               {}
func (*HandleRXInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *HandleRXInfoRequest) GetDevEUI() []byte {
	if m != nil {
		return m.DevEUI
	}
	return nil
}

func (m *HandleRXInfoRequest) GetTxInfo() *TXInfo {
	if m != nil {
		return m.TxInfo
	}
	return nil
}

func (m *HandleRXInfoRequest) GetRxInfo() []*RXInfo {
	if m != nil {
		return m.RxInfo
	}
	return nil
}

type HandleRXInfoResponse struct {
}

func (m *HandleRXInfoResponse) Reset()                    { *m = HandleRXInfoResponse{} }
func (m *HandleRXInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*HandleRXInfoResponse) ProtoMessage()               {}
func (*HandleRXInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type HandleDataUpMACCommandRequest struct {
	// DevEUI of the node.
	DevEUI []byte `protobuf:"bytes,1,opt,name=devEUI,proto3" json:"devEUI,omitempty"`
	// MAC-command was received in the FRMPayload field.
	FrmPayload bool `protobuf:"varint,3,opt,name=frmPayload" json:"frmPayload,omitempty"`
	// Command identifier (specified by the LoRaWAN specs).
	Cid uint32 `protobuf:"varint,5,opt,name=cid" json:"cid,omitempty"`
	// MAC-command payload(s).
	Data [][]byte `protobuf:"bytes,6,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *HandleDataUpMACCommandRequest) Reset()                    { *m = HandleDataUpMACCommandRequest{} }
func (m *HandleDataUpMACCommandRequest) String() string            { return proto.CompactTextString(m) }
func (*HandleDataUpMACCommandRequest) ProtoMessage()               {}
func (*HandleDataUpMACCommandRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *HandleDataUpMACCommandRequest) GetDevEUI() []byte {
	if m != nil {
		return m.DevEUI
	}
	return nil
}

func (m *HandleDataUpMACCommandRequest) GetFrmPayload() bool {
	if m != nil {
		return m.FrmPayload
	}
	return false
}

func (m *HandleDataUpMACCommandRequest) GetCid() uint32 {
	if m != nil {
		return m.Cid
	}
	return 0
}

func (m *HandleDataUpMACCommandRequest) GetData() [][]byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type HandleDataUpMACCommandResponse struct {
}

func (m *HandleDataUpMACCommandResponse) Reset()                    { *m = HandleDataUpMACCommandResponse{} }
func (m *HandleDataUpMACCommandResponse) String() string            { return proto.CompactTextString(m) }
func (*HandleDataUpMACCommandResponse) ProtoMessage()               {}
func (*HandleDataUpMACCommandResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type HandleErrorRequest struct {
	DevEUI []byte `protobuf:"bytes,1,opt,name=devEUI,proto3" json:"devEUI,omitempty"`
	Error  string `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
}

func (m *HandleErrorRequest) Reset()                    { *m = HandleErrorRequest{} }
func (m *HandleErrorRequest) String() string            { return proto.CompactTextString(m) }
func (*HandleErrorRequest) ProtoMessage()               {}
func (*HandleErrorRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *HandleErrorRequest) GetDevEUI() []byte {
	if m != nil {
		return m.DevEUI
	}
	return nil
}

func (m *HandleErrorRequest) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type HandleErrorResponse struct {
}

func (m *HandleErrorResponse) Reset()                    { *m = HandleErrorResponse{} }
func (m *HandleErrorResponse) String() string            { return proto.CompactTextString(m) }
func (*HandleErrorResponse) ProtoMessage()               {}
func (*HandleErrorResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func init() {
	proto.RegisterType((*DataRate)(nil), "nc.DataRate")
	proto.RegisterType((*RXInfo)(nil), "nc.RXInfo")
	proto.RegisterType((*TXInfo)(nil), "nc.TXInfo")
	proto.RegisterType((*HandleRXInfoRequest)(nil), "nc.HandleRXInfoRequest")
	proto.RegisterType((*HandleRXInfoResponse)(nil), "nc.HandleRXInfoResponse")
	proto.RegisterType((*HandleDataUpMACCommandRequest)(nil), "nc.HandleDataUpMACCommandRequest")
	proto.RegisterType((*HandleDataUpMACCommandResponse)(nil), "nc.HandleDataUpMACCommandResponse")
	proto.RegisterType((*HandleErrorRequest)(nil), "nc.HandleErrorRequest")
	proto.RegisterType((*HandleErrorResponse)(nil), "nc.HandleErrorResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for NetworkController service

type NetworkControllerClient interface {
	// HandleRXInfo publishes rx related meta-data.
	HandleRXInfo(ctx context.Context, in *HandleRXInfoRequest, opts ...grpc.CallOption) (*HandleRXInfoResponse, error)
	// HandleDataUpMACCommand publishes a mac-command received by an end-device.
	// This method will only be called in case the mac-command request was
	// enqueued throught the API or when the CID is >= 0x80 (proprietary
	// mac-command range).
	HandleDataUpMACCommand(ctx context.Context, in *HandleDataUpMACCommandRequest, opts ...grpc.CallOption) (*HandleDataUpMACCommandResponse, error)
}

type networkControllerClient struct {
	cc *grpc.ClientConn
}

func NewNetworkControllerClient(cc *grpc.ClientConn) NetworkControllerClient {
	return &networkControllerClient{cc}
}

func (c *networkControllerClient) HandleRXInfo(ctx context.Context, in *HandleRXInfoRequest, opts ...grpc.CallOption) (*HandleRXInfoResponse, error) {
	out := new(HandleRXInfoResponse)
	err := grpc.Invoke(ctx, "/nc.NetworkController/HandleRXInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkControllerClient) HandleDataUpMACCommand(ctx context.Context, in *HandleDataUpMACCommandRequest, opts ...grpc.CallOption) (*HandleDataUpMACCommandResponse, error) {
	out := new(HandleDataUpMACCommandResponse)
	err := grpc.Invoke(ctx, "/nc.NetworkController/HandleDataUpMACCommand", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NetworkController service

type NetworkControllerServer interface {
	// HandleRXInfo publishes rx related meta-data.
	HandleRXInfo(context.Context, *HandleRXInfoRequest) (*HandleRXInfoResponse, error)
	// HandleDataUpMACCommand publishes a mac-command received by an end-device.
	// This method will only be called in case the mac-command request was
	// enqueued throught the API or when the CID is >= 0x80 (proprietary
	// mac-command range).
	HandleDataUpMACCommand(context.Context, *HandleDataUpMACCommandRequest) (*HandleDataUpMACCommandResponse, error)
}

func RegisterNetworkControllerServer(s *grpc.Server, srv NetworkControllerServer) {
	s.RegisterService(&_NetworkController_serviceDesc, srv)
}

func _NetworkController_HandleRXInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleRXInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkControllerServer).HandleRXInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nc.NetworkController/HandleRXInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkControllerServer).HandleRXInfo(ctx, req.(*HandleRXInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkController_HandleDataUpMACCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleDataUpMACCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkControllerServer).HandleDataUpMACCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nc.NetworkController/HandleDataUpMACCommand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkControllerServer).HandleDataUpMACCommand(ctx, req.(*HandleDataUpMACCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _NetworkController_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nc.NetworkController",
	HandlerType: (*NetworkControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandleRXInfo",
			Handler:    _NetworkController_HandleRXInfo_Handler,
		},
		{
			MethodName: "HandleDataUpMACCommand",
			Handler:    _NetworkController_HandleDataUpMACCommand_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nc.proto",
}

func init() { proto.RegisterFile("nc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 470 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x53, 0xcb, 0x6e, 0xd3, 0x40,
	0x14, 0xc5, 0x75, 0x62, 0xec, 0x5b, 0x23, 0xc1, 0x50, 0x82, 0x15, 0x95, 0xc8, 0xcc, 0x2a, 0xab,
	0x2c, 0xc2, 0x17, 0x40, 0x28, 0xa2, 0x0b, 0x2a, 0x74, 0xa1, 0x82, 0x05, 0x9b, 0x89, 0x67, 0x22,
	0x2c, 0xec, 0x19, 0x33, 0x9e, 0x00, 0x5d, 0xc0, 0x92, 0x9f, 0xe2, 0xe7, 0xd0, 0x3c, 0xdc, 0xa4,
	0xa2, 0xa5, 0xbb, 0xfb, 0x38, 0xbe, 0xe7, 0x31, 0x32, 0xa4, 0xb2, 0x5a, 0x74, 0x5a, 0x19, 0x45,
	0x0e, 0x64, 0x45, 0x7f, 0x47, 0x90, 0xbe, 0x64, 0x86, 0x21, 0x33, 0x82, 0xcc, 0x00, 0x5a, 0xc5,
	0xb7, 0x0d, 0x33, 0xb5, 0x92, 0x45, 0x54, 0x46, 0xf3, 0x0c, 0xf7, 0x26, 0xe4, 0x18, 0xb2, 0x35,
	0x93, 0xfc, 0x43, 0xcd, 0xcd, 0xe7, 0xe2, 0xa0, 0x8c, 0xe6, 0xf7, 0x70, 0x37, 0x20, 0x14, 0xf2,
	0xbe, 0xd3, 0x82, 0xf1, 0x57, 0xac, 0x32, 0x4a, 0x17, 0xb1, 0x03, 0x5c, 0x99, 0x91, 0x02, 0xee,
	0xae, 0x6b, 0xa3, 0x99, 0x11, 0xc5, 0xc8, 0xad, 0x87, 0x96, 0x7e, 0x82, 0x04, 0x3f, 0x9e, 0xca,
	0x8d, 0x22, 0xf7, 0x21, 0x6e, 0x59, 0xe5, 0xe8, 0x73, 0xb4, 0x25, 0x21, 0x30, 0x32, 0x75, 0x2b,
	0x1c, 0x65, 0x86, 0xae, 0xb6, 0x33, 0xdd, 0xf7, 0xb5, 0x63, 0x19, 0xa3, 0xab, 0xed, 0xf5, 0x46,
	0x21, 0x7b, 0x77, 0x86, 0xee, 0x7a, 0x84, 0x43, 0x4b, 0x7f, 0x41, 0xf2, 0xde, 0x5f, 0x3f, 0x86,
	0x6c, 0xa3, 0xc5, 0xd7, 0xad, 0x90, 0xd5, 0x85, 0xe3, 0x88, 0x71, 0x37, 0x20, 0x73, 0x48, 0x79,
	0x48, 0xc3, 0xb1, 0x1d, 0x2e, 0xf3, 0x85, 0xac, 0x16, 0x43, 0x42, 0x78, 0xb9, 0xb5, 0x2a, 0x19,
	0xf7, 0x26, 0x53, 0xb4, 0x25, 0x99, 0x42, 0x5a, 0x29, 0x2e, 0x70, 0x30, 0x97, 0xe1, 0x65, 0x4f,
	0xb7, 0xf0, 0xf0, 0x35, 0x93, 0xbc, 0x11, 0xde, 0x23, 0x5a, 0xbe, 0xde, 0x90, 0x09, 0x24, 0x5c,
	0x7c, 0x3b, 0x39, 0x3f, 0x0d, 0x6e, 0x43, 0x47, 0x28, 0x24, 0xe6, 0x87, 0x05, 0xba, 0xfb, 0x87,
	0x4b, 0xb0, 0x22, 0xbc, 0x01, 0x0c, 0x1b, 0x8b, 0xd1, 0x1e, 0x33, 0x2a, 0xe3, 0x01, 0x13, 0xce,
	0x87, 0x0d, 0x9d, 0xc0, 0xd1, 0x55, 0xda, 0xbe, 0x53, 0xb2, 0x17, 0xf4, 0x27, 0x3c, 0xf1, 0x73,
	0x6b, 0xec, 0xbc, 0x7b, 0xf3, 0x7c, 0xb5, 0x52, 0x6d, 0xcb, 0x24, 0xbf, 0x4d, 0xd8, 0x0c, 0x60,
	0xa3, 0xdb, 0xb7, 0xec, 0xa2, 0x51, 0x8c, 0x07, 0xf3, 0x7b, 0x13, 0x9b, 0x4a, 0x55, 0xf3, 0x62,
	0xec, 0xde, 0xd6, 0x96, 0xf6, 0x9d, 0x6c, 0x66, 0x45, 0x52, 0xc6, 0xf3, 0x1c, 0x5d, 0x4d, 0x4b,
	0x98, 0xdd, 0x44, 0x1f, 0x04, 0xbe, 0x00, 0xe2, 0x11, 0x27, 0x5a, 0x2b, 0x7d, 0x9b, 0xaa, 0x23,
	0x18, 0x0b, 0x8b, 0x73, 0x82, 0x32, 0xf4, 0x0d, 0x7d, 0x34, 0x64, 0x1e, 0x6e, 0xf8, 0xd3, 0xcb,
	0x3f, 0x11, 0x3c, 0x38, 0x13, 0xe6, 0xbb, 0xd2, 0x5f, 0x56, 0x4a, 0x1a, 0xad, 0x9a, 0x46, 0x68,
	0xb2, 0x82, 0x7c, 0x3f, 0x29, 0xf2, 0xd8, 0xa6, 0x79, 0xcd, 0x93, 0x4d, 0x8b, 0x7f, 0x17, 0x41,
	0xf3, 0x1d, 0xc2, 0x60, 0x72, 0xbd, 0x2f, 0xf2, 0x74, 0xf7, 0xd5, 0x0d, 0x91, 0x4f, 0xe9, 0xff,
	0x20, 0x03, 0xc5, 0x3a, 0x71, 0xbf, 0xee, 0xb3, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x81, 0x1d,
	0x04, 0x3a, 0xc6, 0x03, 0x00, 0x00,
}
